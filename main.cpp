/*
 *  GiveMeHex
 *  by fG! - reverser@put.as - https://reverse.put.as
 *  in the great covid year of 2021
 *  No rights reserved.
 *
 *  This software is fuck off licensed.
 *  Just fuck off and do whatever you want with it.
 *  It's public domain.
 *
 *  Greetz to:
 *  - Portuguese Covid Vaccination Task Force
 *  You girls and boys rock! Outstanding job!
 *
 *  - NSO, Candiru, Zerodium, Gamma Group, Ability, DarkMatter, Intellexa, Verint, Circles
 *  Keep hacking the Cupertino clowns! Love ya!!!
 *       (¯`v´¯)♥
 *        •.¸.•´
 *     ¸.•´
 *    (
 *  ☻/
 * /▌♥♥
 * / \ ♥♥
 *
 * Fuckz to:
 * - HexRays
 * - HackingTeam
 * - Covid
 *
 * Happy Birthday to put.as, 18 years old already!
 *
 */

#include <ida.hpp>
#include <idp.hpp>
#include <expr.hpp>
#include <bytes.hpp>
#include <loader.hpp>
#include <kernwin.hpp>

struct plugin_data_t : public plugmod_t
{
  ea_t old_ea = BADADDR;
  int old_lnnum = -1;
  virtual bool idaapi run(size_t arg) override;
  idaapi ~plugin_data_t();
};

//--------------------------------------------------------------------------
// if higher than one it will introduce space between the address and bytes/disassembly
static const int prefix_width = 1;

// this is used to add custom output to the disassembly output
// we are going to abuse it by not adding output and changing one byte in the autogenerated address
// the reason for this is that we don't seem to have a way to control the autogenerated string
// other than available options, which don't have adding a 0x prefix to addresses
struct givemehex_prefix_t : public user_defined_prefix_t
{
  plugin_data_t *pd;
  givemehex_prefix_t(plugin_data_t *d) :
    user_defined_prefix_t(prefix_width, d), pd(d) {}
  virtual void idaapi get_user_defined_prefix(
        qstring *out,
        ea_t ea,
        const insn_t &,
        int lnnum,
        int indent,
        const char *line) override
  {
    // the class pointer is available at RDX register when this hook
    // is called from libida64.dylib
    // so we read it to retrieve the string for autogenerated address
    // and we modify it directly
    // fragile and could be done nicer but what's fun about that?
    uint64_t class_addr = 0;
    asm("\t movq %%rbx, %0" : "=r"(class_addr));
    
    out->qclear();        // empty prefix by default

    // in IDA 7.6 SP1 the original string is located at offset 0x68
    // so we just retrieve the pointer to it
    char *original = (char*)(*(uint64_t*)(class_addr+0x68));
#if DEBUG
    msg("class addr: 0x%llx addr: 0x%llx string: %s\n", class_addr, ea, original);
#endif
    if (original == nullptr) {
      return;
    }
    // do nothing if it's the same address (comments, empty lines, directives, etc)
    // we already modified the original string on the first hit 
    // and it's reused for lines with same address
    if (pd->old_ea == ea) {
      return;
    }

    // now we iterate over the original string and find the first zero for the address
    // assumes the address is not very high (for example XNU kernel addresses)
    // have I told you this is fragile hack? friday night, too lazy to get this better
    char *x = original;
    int count = 0;
    while (*x) {
      // when we found the first zero
      // we verify if next character is also a zero
      // and modify it to an 'x' and we have what we wanted
      if (*x == 0x30) {
        char y = *(x+1);
        if (y && y == 0x30) {
          // hax the original string
          original[count+1] = 'x';
          break;
        }
      }
      count++;
      x++;
    }
    
    // Remember the address and line number we produced the line prefix for:
    pd->old_ea = ea;
    pd->old_lnnum = lnnum;
  }
};

//--------------------------------------------------------------------------
static plugmod_t *idaapi init()
{
  plugin_data_t *pd = new plugin_data_t;
  // user-defined prefix. will be automatically uninstalled by the kernel
  // when our plugin gets unloaded.
  new givemehex_prefix_t(pd);
  return pd;
}

//--------------------------------------------------------------------------
plugin_data_t::~plugin_data_t()
{
}

//--------------------------------------------------------------------------
bool idaapi plugin_data_t::run(size_t arg)
{
  msg("------------------\n");
  msg("GiveMeHex started.\n");
  msg("------------------\n");
  return true;
}

//--------------------------------------------------------------------------
static const char comment[] = "Rewrites disassembly view addresses with hex prefix";

static const char help[] =
  "A great plugin module\n"
  "\n"
  "Rewrites disassembly view addresses with hex prefix.\n"
  "\n"
  "So you don't need to keep writing 0x all the time when copy\n"
  "pasting between IDA and debuggers/calcs, etc.\n";

//--------------------------------------------------------------------------
static const char wanted_name[] = "GiveMeHex";
static const char wanted_hotkey[] = "";

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------
plugin_t PLUGIN =
{
  IDP_INTERFACE_VERSION,
  PLUGIN_MULTI,         // plugin flags
  init,                 // initialize
  nullptr,              // terminate. this pointer may be nullptr.
  nullptr,              // invoke plugin
  comment,              // long comment about the plugin
                        // it could appear in the status line
                        // or as a hint
  help,                 // multiline help about the plugin
  wanted_name,          // the preferred short name of the plugin
  wanted_hotkey         // the preferred hotkey to run the plugin
};
