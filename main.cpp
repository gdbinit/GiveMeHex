/*
 *  GiveMeHex
 *  by fG! - reverser@put.as - https://reverse.put.as
 *  in the great covid year of 2021
 *  No rights reserved.
 *
 *  This software is fuck off licensed.
 *  Just fuck off and do whatever you want with it.
 *  It's public domain.
 *
 *  Greetz to:
 *  - Portuguese Covid Vaccination Task Force
 *  You girls and boys rock! Outstanding job!
 *
 *  - NSO, Candiru, Zerodium, Gamma Group, Ability, DarkMatter, Intellexa, Verint, Circles
 *  Keep hacking the Cupertino clowns! Love ya!!!
 *       (¯`v´¯)♥
 *        •.¸.•´
 *     ¸.•´
 *    (
 *  ☻/
 * /▌♥♥
 * / \ ♥♥
 *
 * Fuckz to:
 * - HexRays
 * - HackingTeam
 * - Covid
 *
 * Happy Birthday to put.as, 18 years old already!
 *
 */

#include <ida.hpp>
#include <idp.hpp>
#include <expr.hpp>
#include <bytes.hpp>
#include <loader.hpp>
#include <kernwin.hpp>

// in IDA 7.6 SP1/7.7 the original string is located at offset 0x68
// on libida64.dylib ARM64 version we can find it here on top of the function that calls the plugin
// __text:0000000000028148                 ADD             X22, X19, #0x68 ; 'h'
// __text:000000000002814C                 CBZ             X25, loc_28188
// otherwise just breakpoint on the libda64.dylib function and find the offset
#define ORIGINAL_STRING_OFFSET  0x68

struct plugin_data_t : public plugmod_t
{
  ea_t old_ea = BADADDR;
  int old_lnnum = -1;
  virtual bool idaapi run(size_t arg) override;
  idaapi ~plugin_data_t();
};

//--------------------------------------------------------------------------
// if higher than one it will introduce space between the address and bytes/disassembly
static const int prefix_width = 1;

// this is used to add custom output to the disassembly output
// we are going to abuse it by not adding output and changing one byte in the autogenerated address
// the reason for this is that we don't seem to have a way to control the autogenerated string
// other than available options, which don't have adding a 0x prefix to addresses
struct givemehex_prefix_t : public user_defined_prefix_t
{
  plugin_data_t *pd;
  givemehex_prefix_t(plugin_data_t *d) :
    user_defined_prefix_t(prefix_width, d), pd(d) {}
  virtual void idaapi get_user_defined_prefix(
        qstring *out,
        ea_t ea,
        const insn_t &,
        int lnnum,
        int indent,
        const char *line) override
  {
    // to find out the caller from libida64.dylib just enable this
    // and load IDA under a debugger and then backtrace back to libida64.dylib
    // it's the first hit since the UI plugin is called from a jump/branch register
    // __builtin_trap();

    // the class pointer is available at RBX/X19 register when this hook
    // is called from libida64.dylib
    // so we read it to retrieve the string for autogenerated address
    // and we modify it directly
    // fragile and could be done nicer but what's fun about that?
    uint64_t class_addr = 0;
#ifdef __x86_64__
    asm("\t movq %%rbx, %0" : "=r"(class_addr));
#elif __aarch64__
    asm("\t mov %0, X19" : "=r"(class_addr));
#endif
    out->qclear();        // empty prefix by default
    // something is bad - doesn't avoid bogus pointer values...
    if (class_addr == 0) {
      return;
    }
    // retrieve pointer to the original string from the class
    char *original = (char*)(*(uint64_t*)(class_addr + ORIGINAL_STRING_OFFSET));
#if DEBUG
    msg("class addr: 0x%llx addr: 0x%llx string: %s\n", class_addr, ea, original);
#endif
    if (original == nullptr) {
      return;
    }
    // do nothing if it's the same address (comments, empty lines, directives, etc)
    // we already modified the original string on the first hit 
    // and it's reused for lines with same address
    if (pd->old_ea == ea) {
      return;
    }

    // if address representation is set to function offsets in options
    // we skip it since there is nothing to do
    if (strchr(original, '+')) {
      return;
    }

    // check if include segment addresses option is in use (default)
    // if use segment names isn't set we would hit the segment address instead
    char *x = original;
    char *segment = strchr(original, ':');
    if (segment != NULL) {
      x = segment;
    }

    // now we iterate over the string and find the first digit
    while (*x) {
      if (isdigit(*x)) {
        // check if address can be hacked
        // we can't for XNU addresses that are as high as FFFFFF80006F0E50 for example
        if (*x != '0' || (*(x+1) && *(x+1) != '0')) {
          return;
        }
        // hax the string
        *(x+1) = 'x';
        break;
      }
      x++;
    }
    // Remember the address and line number we produced the line prefix for:
    pd->old_ea = ea;
    pd->old_lnnum = lnnum;
  }
};

//--------------------------------------------------------------------------
static plugmod_t *idaapi init()
{
  plugin_data_t *pd = new plugin_data_t;
  // user-defined prefix. will be automatically uninstalled by the kernel
  // when our plugin gets unloaded.
  new givemehex_prefix_t(pd);
  return pd;
}

//--------------------------------------------------------------------------
plugin_data_t::~plugin_data_t()
{
}

//--------------------------------------------------------------------------
bool idaapi plugin_data_t::run(size_t arg)
{
  msg("------------------\n");
  msg("GiveMeHex started.\n");
  msg("------------------\n");
  return true;
}

//--------------------------------------------------------------------------
static const char comment[] = "Rewrites disassembly view addresses with hex prefix";

static const char help[] =
  "A great plugin module\n"
  "\n"
  "Rewrites disassembly view addresses with hex prefix.\n"
  "\n"
  "So you don't need to keep writing 0x all the time when copy\n"
  "pasting between IDA and debuggers/calcs, etc.\n";

//--------------------------------------------------------------------------
static const char wanted_name[] = "GiveMeHex";
static const char wanted_hotkey[] = "";

//--------------------------------------------------------------------------
//
//      PLUGIN DESCRIPTION BLOCK
//
//--------------------------------------------------------------------------
plugin_t PLUGIN =
{
  IDP_INTERFACE_VERSION,
  PLUGIN_MULTI,         // plugin flags
  init,                 // initialize
  nullptr,              // terminate. this pointer may be nullptr.
  nullptr,              // invoke plugin
  comment,              // long comment about the plugin
                        // it could appear in the status line
                        // or as a hint
  help,                 // multiline help about the plugin
  wanted_name,          // the preferred short name of the plugin
  wanted_hotkey         // the preferred hotkey to run the plugin
};
